/*
 * 
 * Created on Apr 26, 2004
 *
 * Copyright MedCommons 2004
 * sean
 */
package net.medcommons.router.services.wado;

/**
 * 
 * See DICOM supplement 85 on http://www.dclunie.com/dicom-status/status.html for more details about 
 * WADO.
 * 
 * The current code is only a partial implementation of WADO and can't be claimed as compliant with
 * the standard. The missing pieces are:
 * <ul>
 * <li> WADO services must be able to return DICOM objects as well as JPEG. This servlet only
 * 		returns JPEG and PNG (PNG is optional).
 * <li> WADO requires that the image be accessed using the triplet of {StudyInstanceUID,
 * 		SeriesInstanceUID, and SOPInstanceUID}.  Here the combination of filename (fname) and StudyInstanceUID 
 * 		are required because we don't have a database to map the DICOM UIDs to a filename. This
 * 		is a non-standard extension and should be dropped from the code in the future.
 * <li> Grayscale presentation objects not supported.
 * <li> Structured reports not supported.
 * <li> URL Request Type should be "WADO"  - otherwise an error must be thrown.
 * </ul>
 * 
 *  maxRows, maxColumns values are generated by JavaScript. If the values are 'undefined' 
 * then the default behavior follows (scaling is at 1.0).
 * To do: write up a description of each of the parameters.
 * To do: need to do more sanity checking of parameters.
 * @author sean
 *
 */

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.font.FontRenderContext;
import java.awt.font.TextLayout;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.text.DecimalFormat;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.StringTokenizer;

import javax.imageio.ImageIO;
import javax.imageio.ImageReader;
import javax.imageio.ImageWriteParam;
import javax.imageio.ImageWriter;
import javax.imageio.stream.ImageInputStream;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import net.medcommons.router.configuration.Configuration;
import net.medcommons.router.services.wado.utils.WindowLevelTransform;

import org.apache.log4j.Logger;
import org.dcm4che.data.Dataset;
import org.dcm4che.data.DcmElement;
import org.dcm4che.dict.Tags;
import org.dcm4che.image.ColorModelFactory;
import org.dcm4che.image.ColorModelParam;
import org.dcm4che.imageio.plugins.DcmImageReadParam;
import org.dcm4che.imageio.plugins.DcmMetadata;

import com.sun.image.codec.jpeg.JPEGCodec;
import com.sun.image.codec.jpeg.JPEGEncodeParam;
import com.sun.image.codec.jpeg.JPEGImageEncoder;
/**
 * 
 * @author  sdoyle@medcommons.org
 */
public class WADOServlet extends HttpServlet {

	File imageRootDirectory = null;
	Font font = null;
	final static String DEFAULT_FONT = "sansserif";
	int defaultBufferSize = 8096;
	final static Logger log = Logger.getLogger(WADOServlet.class);
	final String PIXEL_REPRESENTATION_MONOCHROME1 = "MONOCHROME1";
	final String PIXEL_REPRESENTATION_MONOCHROME2 = "MONOCHROME2";
	final String PIXEL_REPRESENTATION_RBG = "RGB";

	final static int INTERPOLATION_FAST = 0;
	final static int INTERPOLATION_SMOOTH = 1;

	final String REQUEST_TYPE = "WADO";

	final String CONTENT_TYPE_JPEG = "image/jpeg";
	final String CONTENT_TYPE_DICOM = "image/dicom";
	final String CONTENT_TYPE_PNG = "image/png";
	static DecimalFormat magFormat = null;

	long time[] = new long[6];
	String timeStr[] = new String[6];
	// URL parameter requestType must match this value.

	final static ColorModelFactory cmFactory = ColorModelFactory.getInstance();

	final static Color myGray = new Color(204, 204, 204);

	public void init() {
		try {

			magFormat = new DecimalFormat("#0.00");

			String rootDir =
				(String) Configuration.getInstance().getConfiguredValue(
					"net.medcommons.dicom.directory");

			imageRootDirectory = new File(rootDir);
			if (!imageRootDirectory.exists())
				throw new FileNotFoundException(
					imageRootDirectory.getCanonicalPath());

			font = new Font(DEFAULT_FONT, Font.BOLD, 24);
		} catch (Exception e) {
			e.printStackTrace();
		}

	}

	public void doGet(HttpServletRequest req, HttpServletResponse resp)
		throws ServletException, IOException {
		doPost(req, resp); // Need to put DoS limits.
	}

	public void doPost(HttpServletRequest req, HttpServletResponse resp)
		throws ServletException, IOException {

		String filename = null;
		int frame = 0;
		time[0] = System.currentTimeMillis();
		timeStr[0] = "Start";
		urlParameter uParams = new urlParameter();
		String requestType = null;
    resp.setHeader("Cache-Control","public, max-age=3600");

		Enumeration e = req.getParameterNames();
		while (e.hasMoreElements()) {
			String key = (String) e.nextElement();
			String[] value = req.getParameterValues(key);
			//log.info("key=" +key + "=" +value[0]);
			if (key.equals("fname")) {
				filename = value[0];
			} else if (key.equals("studyUID")) {
				uParams.studyUID = value[0];
			} else if (key.equals("seriesUID")) {
				uParams.seriesUID = value[0];
			} else if (key.equals("objectUID")) {
				uParams.objectUID = value[0];
			} else if (key.equals("frameNumber")) {
				uParams.frameNumber = Integer.parseInt(value[0]);
			} else if (key.equals("windowWidth")) {
				uParams.window = Integer.parseInt(value[0]);
			} else if (key.equals("windowCenter")) {
				uParams.level = Integer.parseInt(value[0]);
			} else if (key.equals("imageQuality")) {
				uParams.imageQuality = Integer.parseInt(value[0]);
			} else if (key.equals("rows")) {
				uParams.rows = Integer.parseInt(value[0]);
			} else if (key.equals("columns")) {
				uParams.columns = Integer.parseInt(value[0]);
			} else if (key.equals("maxRows")) {
				try {
					uParams.maxRows = Integer.parseInt(value[0]);
				} catch (NumberFormatException e1) {
					;
					// Ignore number format errors (maxRows is generated by JavaScript; see above)
				}
			} else if (key.equals("maxColumns")) {
				try {
					uParams.maxColumns = Integer.parseInt(value[0]);
				} catch (NumberFormatException e1) {
					;
					// Ignore number format errors (maxRows is generated by JavaScript; see above)
				}
			} else if (key.equals("requestType")) {
				requestType = value[0];
			} else if (key.equals("windowLevelGrid")) {
				uParams.windowLevelGrid = value[0];
			} else if (key.equals("contentType")) {
				uParams.contentType = value[0];
			} else if (key.equals("region")) {
				int counter = 0;
				StringTokenizer strtok = new StringTokenizer(value[0], ",");
				String tokens[] = new String[4];
				while (strtok.hasMoreTokens()) {
					tokens[counter] = strtok.nextToken();
					counter++;
				}
				if (counter == 4) {
					uParams.topLeftX = Double.parseDouble(tokens[0]);
					uParams.topLeftY = Double.parseDouble(tokens[1]);
					uParams.bottomRightX = Double.parseDouble(tokens[2]);
					uParams.bottomRightY = Double.parseDouble(tokens[3]);
					uParams.regionSpecified = true;

				}

				//log.info("Region specified: " + uParams.regionSpecified);

			} else if (key.equals("annotation")) {
				StringTokenizer strtok = new StringTokenizer(value[0], ",");
				while (strtok.hasMoreTokens()) {
					String token = strtok.nextToken();
					if (token.equals("patient"))
						uParams.patientAnnotation = true;
					else if (token.equals("technique"))
						uParams.techniqueAnnotation = true;
				}
			} else if (key.equals("interpolation")) {
				String interp = value[0];
				if ("FAST".equals(interp))
					uParams.interpolationType = INTERPOLATION_FAST;
			} else if (key.equals("patientName")) {
          uParams.overrideName = true;
          uParams.patientName = value[0];
      }      
			// Other parameters: lut, size.
		}

		parameterCheck(uParams);
		File studyDirectory = new File(imageRootDirectory, uParams.studyUID);
		if (!studyDirectory.exists())
			throw new FileNotFoundException(studyDirectory.getCanonicalPath());
		uParams.imageFile = new File(studyDirectory, filename);

		if (!uParams.imageFile.exists())
			throw new FileNotFoundException(
				uParams.imageFile.getCanonicalPath());
		time[1] = System.currentTimeMillis();
		timeStr[1] = "FoundFile";
		
    log.info("Encoding image series="+uParams.seriesUID + "image=" + uParams.imageFile);
        
    try {
		  encode(uParams, resp);
    }
    catch(IOException exIo) {
        // IOException can occur just because the browser aborted reading.
        // just log info for that rather than throwing up
        log.info("Browser aborted read.");
    }
		
	}

	private BufferedImage windowLevelGrid(
		Dataset dataset,
		urlParameter uParams,
		ImageReader reader)
		throws IOException {
		BufferedImage originalImage = null;
		ColorModelParam cmParam = null;
		cmParam = cmFactory.makeParam(dataset);
		DcmImageReadParam imageParam =
			(DcmImageReadParam) reader.getDefaultReadParam();

		BufferedImage grid[] = new BufferedImage[9];

		for (int i = 0; i < grid.length; i++) {
			dataset.putDS(Tags.WindowCenter, (float) uParams.levelGridArray[i]);
			dataset.putDS(Tags.WindowWidth, (float) uParams.windowGridArray[i]);

			grid[i] = reader.read(uParams.frameNumber, imageParam);
		}

		BufferedImage gridImage =
			new BufferedImage(
				uParams.originalWidth,
				uParams.originalHeight,
				BufferedImage.TYPE_INT_RGB);
		//BufferedImage.TYPE_BYTE_GRAY (faster, but generates slightly bad results:Java bug?)
		Graphics2D g2d = gridImage.createGraphics();

		int nRows = 3;
		int nCols = 3;

		//  Output size of tiles
		int tileWidth = uParams.originalWidth / nCols;
		int tileHeight = uParams.originalHeight / nRows;

		// If there is no region specified - then simply
		// use the center 1/3 of the image as the region
		// to be displayed.
		int newTopLeftX = tileWidth;
		int newTopLeftY = tileHeight;
		int newWidth = tileWidth;
		int newHeight = tileHeight;

		if (uParams.regionSpecified) {
			newTopLeftX = (int) (uParams.topLeftX * uParams.originalWidth);
			newTopLeftY = (int) (uParams.topLeftY * uParams.originalHeight);
			newWidth =
				(int) (uParams.bottomRightX * uParams.originalWidth)
					- newTopLeftX;
			newHeight =
				(int) (uParams.bottomRightY * uParams.originalHeight)
					- newTopLeftY;
			float wRatio = uParams.originalWidth / newWidth;
			float hRatio = uParams.originalHeight / newHeight;
			if (wRatio < hRatio)
				newHeight = (int) (uParams.originalHeight / wRatio);
			else
				newWidth = (int) (uParams.originalWidth / hRatio);
			// Adjust starting coordinates to remain inside of image.
			if ((newTopLeftX + newWidth) > uParams.originalWidth)
				newTopLeftX = uParams.originalWidth - newWidth;
			if ((newTopLeftY + newHeight) > uParams.originalHeight)
				newTopLeftY = uParams.originalHeight - newHeight;
			/*
			System.out.println("newWidth="  + newWidth + ", newHeight=" + newHeight); 
			System.out.println("newTopLeftX = " + newTopLeftX + ", newTopLeftY= " +
				newTopLeftY);
			*/
			
			
		}

		for (int i = 0; i < nRows; i++) {
			for (int j = 0; j < nCols; j++) {
				int index = (i * nCols) + j;
				//System.out.println("Index is " + index);
				g2d.drawImage(
					grid[index].getSubimage(
						newTopLeftX,
						newTopLeftY,
						newWidth,
						newHeight),
					tileWidth * j,
					tileHeight * i,
					tileWidth,
					tileHeight,
					null);
			}

		}

		g2d.dispose();
		return (gridImage);
	}
	private BufferedImage windowLevelImage(
		Dataset dataset,
		urlParameter uParams,
		ImageReader reader)
		throws IOException {
		BufferedImage originalImage = null;
		ColorModelParam cmParam = null;
		cmParam = cmFactory.makeParam(dataset);
		DcmImageReadParam imageParam =
			(DcmImageReadParam) reader.getDefaultReadParam();

		// Only set window/level values if they are specified on the URL. 
		if ((uParams.level != Integer.MIN_VALUE)
			&& (uParams.window != Integer.MAX_VALUE)) {
			//cmParam.update(uParams.level, uParams.window, false);
			dataset.putDS(Tags.WindowCenter, (float) uParams.level);
			dataset.putDS(Tags.WindowWidth, (float) uParams.window);
		}
		String modality = dataset.getString(Tags.Modality);
		String sFrames = dataset.getString(Tags.NumberOfFrames);
		if ((sFrames != null) && (!"".equals(sFrames))){
			try{
				uParams.numberOfFrames = Integer.parseInt(sFrames);
			}
			catch(Exception e){
				e.printStackTrace();
			}
		}
		// Set window/level values if they 
		// a) aren't set in the URL
		// and
		// b) there isn't a DICOM default.
		if (modality.equals("CT")) {

			if (uParams.window == Integer.MIN_VALUE) {
				String window = dataset.getString(Tags.WindowWidth);
				try {
					uParams.window = Integer.parseInt(window);
				} catch (Exception e) {
					//log.info("No window attribute in image");
					uParams.window = 600;

					dataset.putDS(Tags.WindowWidth, (float) uParams.window);
				}

			}
			if (uParams.level == Integer.MIN_VALUE) {
				String level = dataset.getString(Tags.WindowCenter);
				try {
					uParams.level = Integer.parseInt(level);
				} catch (Exception e) {
					//log.info("No level attribute in image");
					uParams.level = 100;
					dataset.putDS(Tags.WindowCenter, (float) uParams.level);
				}
			}
		}
		// KLUDGE.
		// Rescaling for interpolationType==SMOOTH results
		// in window/level values being rendered incorrectly.
		// Input matrix appears to be the same.
		// The KLUDGE means that the slower data path is 
		// taken for window/level when SMOOTH interpolation
		// is performed - making it even slower. But the output is correct.
		// If no Window/Level values are abil
		if (modality.equals("CT")
			&& (uParams.interpolationType == INTERPOLATION_FAST)) {

			DcmElement el = dataset.get(Tags.PixelData);

			long imageSize =
				(uParams.originalHeight * uParams.originalWidth * 2);
			// hack
			long startBytes = uParams.imageFile.length() - imageSize;
			// el.getStreamPosition();
			long endBytes = startBytes + imageSize; //el.length();
			WindowLevelTransform wlt = new WindowLevelTransform();
			uParams.photometricInterpretation =
				dataset.getString(Tags.PhotometricInterpretation);
			originalImage =
				wlt.window12to8Bits(
					uParams.imageFile,
					uParams.window,
					uParams.level,
					uParams.originalWidth,
					uParams.originalHeight,
					uParams.photometricInterpretation,
					startBytes,
					endBytes);
			; // use NIO back door
		} else {
			originalImage = reader.read(uParams.frameNumber, imageParam);

		}

		//System.out.println("Original image is " + originalImage);
		return (originalImage);
	}
	/**
	 * Encodes the DICOM image as a JPEG stream.
	 * 
	 * Several transforms are performed during this process:
	 * <ul>
	 * <li> Images are mapped to 8 bit values using LUT.
	 * <li> Images are rescaled
	 * <li> <i>Future</i> Image subregions
	 * </ul>
	 * @param uParams
	 * @param out
	 * @param lut
	 * @throws IOException
	 */
	public void encode(urlParameter uParams, HttpServletResponse response)
		throws IOException {
		Iterator iter = ImageIO.getImageReadersByFormatName("DICOM");
		//OutputStream out = response.getOutputStream();
		double imageScale = 1.0;
		ImageReader reader = (ImageReader) iter.next();
		ColorModelParam cmParam = null;
		DcmImageReadParam imageParam =
			(DcmImageReadParam) reader.getDefaultReadParam();

		ImageInputStream iis =
			ImageIO.createImageInputStream(uParams.imageFile);

		BufferedImage originalImage = null, outputImage = null;
		try {
			reader.setInput(iis, false);
			Dataset dataset =
				((DcmMetadata) reader.getStreamMetadata()).getDataset();
			uParams.originalWidth = reader.getWidth(uParams.frameNumber);
			uParams.originalHeight = reader.getHeight(uParams.frameNumber);

			if (uParams.windowLevelGrid == null) {
				originalImage = windowLevelImage(dataset, uParams, reader);
			} else {
				originalImage = windowLevelGrid(dataset, uParams, reader);
			}

			time[2] = System.currentTimeMillis();
			timeStr[2] = "Past window/level";

			if (originalImage == null) {
				log.info(
					"Image could not be read:"
						+ uParams.imageFile.getCanonicalPath());
				return;
			}

			// If a subregion is identified *and* it is not the windowLevelGrid case
			// (which extracts a set of subregions using different logic) then
			// extract an image subrectangle before other transforms are performed.
			if (uParams.regionSpecified && (uParams.windowLevelGrid == null)) {
				int newTopLeftX =
					(int) (uParams.topLeftX * uParams.originalWidth);
				int newTopLeftY =
					(int) (uParams.topLeftY * uParams.originalHeight);
				int newWidth =
					(int) (uParams.bottomRightX * uParams.originalWidth)
						- newTopLeftX;
				int newHeight =
					(int) (uParams.bottomRightY * uParams.originalHeight)
						- newTopLeftY;
						
			 	// Adjust magnified image to fit aspect ratio
				float wRatio = uParams.maxColumns / newWidth;
				float hRatio = uParams.maxRows / newHeight;
				float minRatio = Math.min(wRatio, hRatio);
				float maxRatio = Math.max(wRatio, hRatio);
				//log.info("minRatio = " + minRatio);
			//float wRatio = uParams.originalWidth / newWidth;
			//float hRatio = uParams.originalHeight / newHeight;
				newHeight = (int) (uParams.originalHeight/minRatio);
				newWidth = (int) (uParams.originalWidth/minRatio);
				
				// If rescaled image goes out of bounds then move
				// coordinates.
				// A bit of a kludge - should rewrite using rectangles
				// with intersection, clipping regions.
				if ((newHeight + newTopLeftY)> uParams.originalHeight)
					newTopLeftY = uParams.originalHeight - newHeight - 1;
				if ((newWidth + newTopLeftX)> uParams.originalWidth)
					newTopLeftX = uParams.originalWidth - newWidth -1;
				/*
				if (wRatio > hRatio)
					newHeight = (int) (uParams.originalHeight / wRatio);
				else
					newWidth = (int) (uParams.originalWidth / hRatio);
				*/
				
				//log.info("x=" + newTopLeftX + ", y=" + newTopLeftY + ", w=" + newWidth + ", h=" + newHeight);
				originalImage =
					originalImage.getSubimage(
						newTopLeftX,
						newTopLeftY,
						newWidth,
						newHeight);
				uParams.originalWidth = newWidth;
				uParams.originalHeight = newHeight;
			}
			if (scalingRequired(uParams)) {

				imageScale = calculateScale(uParams);
				if (uParams.interpolationType == INTERPOLATION_FAST) {
					AffineTransform affineTransform =
						AffineTransform.getScaleInstance(
							imageScale,
							imageScale);

					AffineTransformOp affineTransformOp =
						new AffineTransformOp(affineTransform, null);

					outputImage = affineTransformOp.filter(originalImage, null);
				} else {

					outputImage =
						new BufferedImage(
							uParams.outputWidth,
							uParams.outputHeight,
							BufferedImage.TYPE_BYTE_GRAY);

					Graphics2D g2d = outputImage.createGraphics();
					g2d.setRenderingHint(
						RenderingHints.KEY_INTERPOLATION,
						RenderingHints.VALUE_INTERPOLATION_BILINEAR);
					g2d.drawImage(
						originalImage,
						0,
						0,
						uParams.outputWidth,
						uParams.outputHeight,
						null);
					g2d.dispose();
				}
				time[3] = System.currentTimeMillis();
				timeStr[3] = "Past affine transform";

			} else {

				// Render the image at its original size.
				outputImage = originalImage;
				time[3] = System.currentTimeMillis();
				timeStr[3] = "Past affine transform";
			}
			renderTextOverlay(outputImage, dataset, imageScale, uParams);
			time[4] = System.currentTimeMillis();
			timeStr[4] = "Past text render";

		} finally {
			try {
				iis.close();
			} catch (IOException ignore) {
			}
		}

		if (uParams.contentType.equals(CONTENT_TYPE_JPEG))
			jpegEncode(outputImage, response, uParams.imageQuality);
		else if (uParams.contentType.equals(CONTENT_TYPE_PNG))
			pngEncode(outputImage, response);
		else
			throw new IllegalArgumentException(
				"Uknown content type:" + uParams.contentType);
		time[5] = System.currentTimeMillis();
		timeStr[5] = "Past Image Encode";
		//for (int i = 0; i < time.length; i++)
		//	log.info("  " + timeStr[i] + ":" + (time[i] - time[0]) + " msec");

	}

	/*
	 *  JPEG image encoding the old fashioned way.
	 * Not that speedy - but it beats out the new ImageIO methods.
	 * 
	 */
	private void jpegEncode(
		BufferedImage outputImage,
		HttpServletResponse response,
		int imageQuality)
		throws IOException {
		OutputStream out = response.getOutputStream();
		try {
			response.setContentType("image/jpeg");

			JPEGImageEncoder enc = JPEGCodec.createJPEGEncoder(out);
			JPEGEncodeParam param = enc.getDefaultJPEGEncodeParam(outputImage);
			if (imageQuality != 100)
				param.setQuality((float) (imageQuality / 100.0f), true);
			enc.setJPEGEncodeParam(param);

			enc.encode(outputImage);
		} finally {
			out.close();
		}
	}

	/**
	 * JPEG encoding the ImageIO way. Slow as a dog.
	 * @author sean
	 *
	 */

	private void jpegEncodenew(
		BufferedImage outputImage,
		HttpServletResponse response,
		int imageQuality)
		throws IOException {
		OutputStream out = response.getOutputStream();
		try {

			response.setContentType("image/jpeg");
			Iterator iter = ImageIO.getImageWritersByFormatName("jpeg");
			ImageWriter writer = (ImageWriter) iter.next();
			ImageWriteParam writeParam = writer.getDefaultWriteParam();

			writer.setOutput(
				ImageIO.createImageOutputStream(response.getOutputStream()));
			writer.write(outputImage);

		} finally {
			;
		}
	}
	/**
	 * Generates a PNG output image. Slow as a dog.
	 * @param outputImage
	 * @param out
	 * @throws IOException
	 */
	private void pngEncode(
		BufferedImage outputImage,
		HttpServletResponse response)
		throws IOException {
		OutputStream out = response.getOutputStream();
		try {

			response.setContentType("image/png");
			Iterator iter = ImageIO.getImageWritersByFormatName("png");
			ImageWriter writer = (ImageWriter) iter.next();
			ImageWriteParam writeParam = writer.getDefaultWriteParam();

			writer.setOutput(
				ImageIO.createImageOutputStream(response.getOutputStream()));
			writer.write(outputImage);

		} finally {
			;
		}
	}

	/**
	 * Returns true if the image requires scaling, false otherwise.
	 * @param uParams
	 * @return
	 */
	private boolean scalingRequired(urlParameter uParams) {
		boolean returnVal = false;
		if ((uParams.columns != Integer.MIN_VALUE)
			&& (uParams.rows != Integer.MIN_VALUE))
			returnVal = true;
		else if (
			(uParams.maxColumns != Integer.MIN_VALUE)
				&& (uParams.maxRows != Integer.MIN_VALUE))
			returnVal = true;
		return (returnVal);
	}

	/**
	 * Calculates the scaling factor for the image.
	 * 
	 * Takes into account the aspect ratio of the image and the aspect ratio of the 
	 * browser's frame size.
	 * 
	 * @param uParams
	 * @return
	 */
	double calculateScale(urlParameter uParams) {
		double scale = 1.0;
		double scaleWidth, scaleHeight;

		if ((uParams.columns != Integer.MIN_VALUE)
			&& (uParams.rows != Integer.MIN_VALUE)) {
			scaleWidth =
				((double) uParams.columns) / ((double) uParams.originalWidth);
			scaleHeight =
				((double) uParams.rows) / ((double) uParams.originalHeight);
			scale = Math.min(scaleWidth, scaleHeight);
			uParams.outputWidth = uParams.columns;
			uParams.outputHeight = uParams.rows;
		} else if (
			(uParams.maxColumns != Integer.MIN_VALUE)
				&& (uParams.maxRows != Integer.MIN_VALUE)) {

			scaleWidth =
				((double) uParams.maxColumns)
					/ ((double) uParams.originalWidth);
			scaleHeight =
				((double) uParams.maxRows) / ((double) uParams.originalHeight);
			scale = Math.min(scaleWidth, scaleHeight);

			uParams.outputWidth = (int) (uParams.originalWidth * scale);
			uParams.outputHeight = (int) (uParams.originalHeight * scale);
		}
		return (scale);
	}
	/**
	 * Renders the overlay text on the output image.
	 * 
	 * Needs rethinking: there will be lists of items to be rendered. How to represent
	 * coordinates? Need something like a layout manager.
	 * @param outputImage
	 * @param dataset
	 * @param imageScale
	 */
	private void renderTextOverlay(
		BufferedImage outputImage,
		Dataset dataset,
		double imageScale,
		urlParameter uParams) {
		float x, y;
		int imageW = outputImage.getWidth();
		int imageH = outputImage.getHeight();
		Graphics2D graphics = outputImage.createGraphics();
		FontRenderContext frc = graphics.getFontRenderContext();
		TextLayout tl = null;

		int verticalSpacing = 10;
		int horizontalEdgeSpacing = 4;

		if (uParams.patientAnnotation) {

			String patientName = dataset.getString(Tags.PatientName);      
      if(uParams.overrideName) {
        patientName = uParams.patientName;
      }
      
			if ((patientName == null) || (patientName.equals("")))
				patientName = "MISSING PATIENT NAME";
			tl = new TextLayout(patientName, font, frc);

			// gets the width and height of the bounds of the Text
			double sw = tl.getBounds().getWidth();
			double sh = tl.getBounds().getHeight();

			x = (float) (outputImage.getWidth() - sw - horizontalEdgeSpacing);
			y = (float) (sh) + verticalSpacing;
			tl.draw(graphics, x, y);

			String patientID = dataset.getString(Tags.PatientID);
			tl = new TextLayout(patientID, font, frc);
			sw = tl.getBounds().getWidth();
			sh = tl.getBounds().getHeight();
			x = (float) (outputImage.getWidth() - sw - horizontalEdgeSpacing);
			y += tl.getBounds().getHeight() + verticalSpacing;
			tl.draw(graphics, x, y);

			String age = dataset.getString(Tags.PatientAge);
			if ((age == null) || (age.equals(""))) {
				age = dataset.getString(Tags.PatientBirthDate);
			}

			String sex = dataset.getString(Tags.PatientSex);

			tl = new TextLayout(sex + " " + age, font, frc);
			sw = tl.getBounds().getWidth();
			sh = tl.getBounds().getHeight();
			x = (float) (outputImage.getWidth() - sw - horizontalEdgeSpacing);
			y += tl.getBounds().getHeight() + verticalSpacing;
			tl.draw(graphics, x, y);

		}
		if (uParams.techniqueAnnotation) {
			x = 0.0f;
			y = (float) (imageH * 0.75);
			tl =
				new TextLayout(
					uParams.originalWidth + " x " + uParams.originalHeight,
					font,
					frc);
			tl.draw(graphics, x, y);
			y += tl.getBounds().getHeight() + verticalSpacing;

			String magnificationFactor = magFormat.format(imageScale);
			tl = new TextLayout("Mag: " + magnificationFactor + "x", font, frc);
			tl.draw(graphics, x, y);

			String sliceThickness = dataset.getString(Tags.SliceThickness);
			if ((sliceThickness != null) && (!sliceThickness.equals(""))) {

				tl = new TextLayout("ST: " + sliceThickness, font, frc);
				y += tl.getBounds().getHeight() + verticalSpacing;
				tl.draw(graphics, x, y);
			}

			String kvp = dataset.getString(Tags.KVP);
			if ((kvp != null) && (!kvp.equals(""))) {

				tl = new TextLayout("KVP: " + kvp, font, frc);
				y += tl.getBounds().getHeight() + verticalSpacing;
				tl.draw(graphics, x, y);
			}

			y += tl.getBounds().getHeight() + verticalSpacing;
			tl =
				new TextLayout(
					"Img:" + dataset.getString(Tags.InstanceNumber),
					font,
					frc);
			tl.draw(graphics, x, y);
			if (uParams.windowLevelGrid == null) {
				// Only need to draw one window/level value
				String window = dataset.getString(Tags.WindowWidth);
				String level = dataset.getString(Tags.WindowCenter);

				tl = new TextLayout("W:" + window + " L:" + level, font, frc);
				y = (float) (imageH - tl.getBounds().getHeight());
				tl.draw(graphics, x, y);
			} else {
				int nRows = 3;
				int nCols = 3;
				for (int i = 0; i < nRows; i++) {
					for (int j = 0; j < nCols; j++) {
						int subimageWidth = imageW / nCols;
						int subimageHeight = imageH / nRows;
						int index = (i * nCols) + j;

						int window = uParams.windowGridArray[index];
						int level = uParams.levelGridArray[index];
						tl =
							new TextLayout(
								"W:" + window + " L:" + level,
								font,
								frc);
						x = subimageWidth * j;
						y =
							(float) (subimageHeight * (i + 1)
								- tl.getBounds().getHeight());
						tl.draw(graphics, x, y);
						/*
						log.info("i" + index);
						log.info("subImageWidth=" + subimageWidth);
						log.info("subImageHeight=" + subimageHeight);
						
						log.info("x" + x);
						log.info("y" + y);
						log.info("window: " + window);
						log.info("level: " + level);
						log.info("====");
						*/
					}
				}
			}

		}
	}

	/**
	 * Performs some sanity checks for input parameters. Makes minor adjustments if 
	 * necessary.
	 * @param uParams
	 */
	private void parameterCheck(urlParameter uParams) {
		double width = uParams.bottomRightX - uParams.topLeftX;
		double height = uParams.bottomRightY - uParams.topLeftY;

		if (uParams.regionSpecified) {

			if (width < 0.1) {
				uParams.bottomRightX = uParams.topLeftX + 0.1f;
			}
			if (height < 0.1) {
				uParams.bottomRightY = uParams.topLeftY + 0.1f;
			}
			if (uParams.bottomRightX > 1.0f) {
				double diff = 1.0f - uParams.bottomRightX;
				uParams.bottomRightX = 1.0;
				uParams.topLeftX -= diff;
			}
			if (uParams.bottomRightY > 1.0f) {
				double diff = 1.0f - uParams.bottomRightY;
				uParams.bottomRightY = 1.0;
				uParams.topLeftY -= diff;
			}

			if (uParams.topLeftX < 0.0f) {
				uParams.bottomRightX -= uParams.topLeftX;
				uParams.topLeftX = 0.0f;
			}
			if (uParams.topLeftY < 0.0f) {
				uParams.bottomRightY -= uParams.topLeftY;
				uParams.topLeftY = 0.0f;
			}
		}
		if (uParams.windowLevelGrid != null) {
			StringTokenizer tok =
				new StringTokenizer(uParams.windowLevelGrid, ",");
			int i = 0;
			uParams.windowGridArray = new int[9];
			uParams.levelGridArray = new int[9];
			//System.out.println("url: " + uParams.windowLevelGrid);
			while (tok.hasMoreTokens()) {
				try {
					if (i > 8)
						break;
					int w = Integer.parseInt(tok.nextToken());
					int l = Integer.parseInt(tok.nextToken());
					//System.out.println("w=" + w);
					//System.out.println("l=" + l);
					uParams.windowGridArray[i] = w;
					uParams.levelGridArray[i] = l;
					i++;
				} catch (Exception e) {
					e.printStackTrace();
					uParams.windowGridArray[i] = i * 100;
					uParams.levelGridArray[i] = i * 100;
				}
			}
		}
	}

	/**
	 * Class for holding parameters specified on URL.
	 */
	class urlParameter {

		File imageFile = null;
		int frameNumber = 0;
		int rows = Integer.MIN_VALUE;
		int columns = Integer.MIN_VALUE;
		int maxRows = Integer.MIN_VALUE;
		int maxColumns = Integer.MIN_VALUE;
		int window = Integer.MIN_VALUE;
		int level = Integer.MIN_VALUE;
		String studyUID = null;
		String seriesUID = null;
		String objectUID = null;
		boolean patientAnnotation = false;
		boolean techniqueAnnotation = false;
		String contentType = CONTENT_TYPE_JPEG;
		boolean regionSpecified = false;
		double topLeftX = 0.0;
		double topLeftY = 0.0;
		double bottomRightX = 0.0;
		double bottomRightY = 0.0;
		int imageQuality = 100; // Highest quality
    boolean overrideName=false;
    String patientName = "";

		int originalWidth = Integer.MIN_VALUE;
		int originalHeight = Integer.MIN_VALUE;
		int numberOfFrames = Integer.MIN_VALUE;
		String photometricInterpretation = null;
		int outputWidth = Integer.MIN_VALUE;
		int outputHeight = Integer.MIN_VALUE;

		int interpolationType = INTERPOLATION_SMOOTH;

		String windowLevelGrid = null;
		int windowGridArray[] = null;
		int levelGridArray[] = null;

		public String toString() {
			StringBuffer buff = new StringBuffer("parameterBlock[");
			buff.append("\n originalWidth = " + originalWidth);
			buff.append("\n imageFile = " + imageFile);
			buff.append("\n frameNumber = " + frameNumber);
			buff.append("\n rows = " + rows);
			buff.append("\n columns = " + columns);
			buff.append("\n maxRows = " + maxRows);
			buff.append("\n maxColumns = " + maxColumns);
			buff.append("\n window = " + window);
			buff.append("\n level = " + level);
			buff.append("\n studyUID = " + studyUID);
			buff.append("\n seriesUID = " + seriesUID);
			buff.append("\n objectUID = " + objectUID);
			buff.append("\n patientAnnotation = " + patientAnnotation);
			buff.append("\n techniqueAnnotation = " + techniqueAnnotation);
			buff.append("\n contentType = " + contentType);
			buff.append("\n regionSpecified = " + regionSpecified);
			buff.append("\n topLeftX = " + topLeftX);
			buff.append("\n topLeftY = " + topLeftY);
			buff.append("\n bottomRightX = " + bottomRightX);
			buff.append("\n bottomRightY = " + bottomRightY);
			buff.append("\n imageQuality = " + imageQuality);
			buff.append("\n originalWidth = " + originalWidth);
			buff.append("\n originalHeight = " + originalHeight);
			buff.append("\n numberOfFrames = " + numberOfFrames);
			buff.append(
				"\n photometricInterpretation = " + photometricInterpretation);
			buff.append("\n outputWidth = " + outputWidth);
			buff.append("\n outputHeight = " + outputHeight);
			buff.append("\n windowLevelGrid = " + windowLevelGrid);
			if (interpolationType == INTERPOLATION_FAST)
				buff.append("\n interpolationType = FAST");
			else
				buff.append("\n interpolationType = SMOOTH");
			buff.append("  ]");

			return (buff.toString());
		}
	}

}
