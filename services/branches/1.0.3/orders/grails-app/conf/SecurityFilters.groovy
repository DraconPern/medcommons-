import javax.crypto.Cipher// import net.medcommons.rest.*;import javax.crypto.spec.IvParameterSpecimport javax.crypto.spec.SecretKeySpecimport java.net.URLEncoder;import java.security.MessageDigestimport net.oauth.*;import net.oauth.server.OAuthServlet;import org.apache.commons.codec.binary.Base64import org.apache.log4j.Logger;import org.codehaus.groovy.grails.commons.GrailsApplication;import javax.servlet.http.*import groovy.sql.Sql/** * Adds Filters to check security *  * @author ssadedin */
public class SecurityFilters {    	private static Logger log = Logger.getLogger(SecurityFilters)    static {        println "Starting"                /*        System.setProperty("DisableSSLCertValidation","true")        RESTUtil.initSSL()
        RESTUtil.init(new SystemPropertyRESTConfiguration())        */    }
    
	SettingsService settingsService		def config		Map settings		SecurityFilters() {		log.info "New Security Filter"	}
	
    def filters = {
        all(controller:'*', action:'*') {
            before = {                				config = grailsApplication.config     			settings = settingsService.get()                	            log.info "request.ctx = " + request.ctx	                                if(!request.ctx) {					request.ctx = config.context 		                log.info "CONTEXT : " + request.ctx                }                                session.security = config.security                if(request.getAttribute("SECURITY_MODEL")) {                	session.security = request.getAttribute("SECURITY_MODEL")                	log.info "Security model set from AJP"                }                else                 	log.info "Security model set from config"                                                log.info "Security model = " + session.security                if(session.security == "ip") {                                        log.info "Using ip based security:  default group is " + settings.acDefaultDODXProvider                    def groupAccId = checkIpAddress(request, controllerName, actionName)                                        // WithAJP ip based security, *anybody* can create an order,                    // however unidentified users will go to the                     // default DOD group only (TIMC group for TIMC)                    log.info "Action name is " + actionName                    if(!groupAccId && controllerName == "order" && (actionName in [null,"","index","form"])) {                        groupAccId = settings.acDefaultDODXProvider                    }                                        if(groupAccId) {                        session.info = [activeGroupAccid: groupAccId]                        return true                    }                }                                                log.info "Context = " + request.ctx                def url = [grailsApplication.config.grails.serverURL]                if(request.ctx)                    url << request.ctx                if(controllerName)                    url << controllerName                if(actionName)                    url << actionName                url = url.collect({it.replaceAll('^/*|/*$',"")}).join("/") +                             (request.queryString?"?"+request.queryString:"")                
                // Is the request signed with OAuth?                if(request.getParameter("oauth_token") != null) {                    log.info("Got request signed with OAuth:  " + url)                    try {                        if(verifyOAuthCall(request,session, url))                            return true                    }                    catch(OAuthProblemException e) {                        log.info("Problem verifying OAuth signature: " +                                 "Signature: $e.parameters.oauth_signature" +                                "Base String: $e.parameters.oauth_signature_base_string")                        throw e                    }                    catch(Exception e) {                        log.error("Failure while verifying OAuth call: " + e);                    }                }                else                    log.info "No OAuth signature"               
                // Have we got an 'mc' cookie
                def c = request.cookies.find {it.name == 'mc'}
                
                // No cookie, not logged in!				String loginUrl = config.appliance+                'acct/login.php?next='+                URLEncoder.encode(url)                if(!c) {		            if(hasOrderWithGroup(actionName, controllerName, params))                        return true;                    
                    redirect(url: loginUrl)                    log.info "User not logged in."
                    // return false                         return
                }                                def mc = URLDecoder.decode(c.value)                
                // Got cookie, is it real?                if(session.mc == mc) {                    log.info "Existing session"                    return true;                }                                def login = checkCookie(mc)
                if(login?.auth) {                    initSessionFromCookie(session,mc,login)
                    return true                }                               if(hasOrderWithGroup(actionName, controllerName, params))                return true;                                // Failed:  redirect to login page
                redirect(url:loginUrl)
                return false    
        }
      }
    }    static final long GROUP_IPADDRESS_CACHE_TIME_MS = 60000L        static Map groupAddresses = [:]        static long groupAddressLoadTimeMs = -1L    boolean hasOrderWithGroup(def actionName, def controllerName, def params) {        // If they are not logged in, but are creating an order AND have        // specified the group to create it for, then that is OK        return (controllerName == "order" && (actionName in [null,"","index","form"])) && params.groupAccountId     }        /**     * Initialize the web session from the specified cookie / attributes     */    def initSessionFromCookie(def session, String mc, def login) {        session.mc = mc        session.info = login                log.info "Loading user " + session.info.mcid        User user = User.findById(session.info.mcid)                log.info "Found user " + user.id + " with active group " + user.activeGroupAccid        session.info.activeGroupAccid = user.activeGroupAccid                log.info "User is logged in as " + login.mcid    }    /**     * Validate the parameters in specified request and check the OAuth     * signature.  If the signature is valid, then create a session based     * on the active group of the individual (if an access token provided)     * or the group linked to the consumer token.      *      * @param request     * @param session     * @param url     * @return true if verified      */    boolean verifyOAuthCall(def request, def session, def url) {        OAuthMessage msg = OAuthServlet.getMessage(request, url)        AuthenticationToken cons = null        AuthenticationToken token = null        if(msg.token) {            // Can we find the specified token            token = AuthenticationToken.findByToken(msg.token)            if(!token)                 throw new Exception("Invalid OAuth token provided: " + msg.token)                        log.info "Found access token " + token                        cons = token.parent            if(cons.token != msg.consumerKey)                throw new Exception("Bad consumer key " + msg.consumerKey + " for token " + token.token)        }        else        if(msg.consumerKey) {            // 2 legged OAuth with consumer key linked to group?            cons = AuthenticationToken.findByToken(msg.consumerKey)            if(!cons || cons.parent.id != cons.id)                throw new Exception("Bad consumer key " + msg.consumerKey + " for token " + msg.token)                        log.info("Found consumer token: " + cons.getAccountId() + " with secret " + cons.secret)        }                if(!cons)            throw new Exception("Invalid or missing consumer key")                OAuthServiceProvider svc = new OAuthServiceProvider(null,null,null)        OAuthConsumer consumer =                         new OAuthConsumer(null, cons.token, cons.secret, svc)        OAuthAccessor accessor = new OAuthAccessor(consumer)        accessor.accessToken = msg.getToken()        accessor.tokenSecret = token?.secret?:""        OAuthValidator validator = new SimpleOAuthValidator(300000, 1.1)        validator.validateMessage(msg, accessor)                if(token) {            def user = User.findByMcid(token.accountId)            if(!user)                throw new Exception("User specified by token does not exist");            session.info = [activeGroupAccid: user.activeGroupAccid]        }        else             session.info = [activeGroupAccid: cons.accountId]    }            /**     * Check that the ip address is either one of the predetermined ip addresses     * that is whitelisted OR matches that of the original uploader of      * an order being accessed.     *      * @param request     * @param controllerName     * @param actionName     * @return     */    String checkIpAddress(def request, def controllerName, def actionName) {        HttpServletRequest req = request        log.info "Got request from " + req.remoteAddr                // If cache is too old, load it        if(System.currentTimeMillis() - groupAddressLoadTimeMs > GROUP_IPADDRESS_CACHE_TIME_MS) {            log.info "Loading group ip addresses from DB"            Map addr = [:]            def addresses = GroupIpaddress.findAll()            addresses.each {                log.info "Mapping ip address " + it.ipaddress + " (len=${it.ipaddress.size()}) to account " + it.accid                addr[it.ipaddress] = it.accid            }            groupAddressLoadTimeMs = System.currentTimeMillis()            groupAddresses = addr        }                if(!groupAddresses.containsKey(req.remoteAddr)) {            log.info "Ip address ${req.remoteAddr} (len=${req.remoteAddr.size()}) not in fixed white list (size = ${groupAddresses.size()}): checking for access by uploader"                        return checkAccessByUploader(req, controllerName, actionName)        }                log.info "Found ip address mapping for ${req.remoteAddr}"        return groupAddresses[req.remoteAddr]    }        javax.sql.DataSource dataSource         /**     * Check if the caller is querying order status AND the ip address      * of the caller matches the ip address of the person who uploaded      * the DICOM for the order.     */    String checkAccessByUploader(def req, def controllerName, def actionName) {        // log.info "Controller is ${controllerName}"        if(controllerName != "orderstatus")        return null                // log.info "Action name is ${actionName}"        if(!(actionName  in ["index",null,""]))        return null                // Is there an anon_auth cookie?        def anonAuth = req.cookies.find {it.name == 'mc_anon_auth'}        if(!anonAuth)        return null                log.info "Found anonymous auth cookie " + anonAuth.value                // At this point we know they are accessing order status        // But are they the uploader?  Sigh.  We have to hit the        // DB.  NB - it may make sense to move this into the         // actual OrderStatus controller because it has to         // hit the DB anyway.                // Find the order that matches the reference they are requesting        def ref = req.getParameter("callers_order_reference")        if(!ref)        return null                log.info "Reference is " + ref                Sql sql = new Sql(dataSource)        def row = sql.firstRow(        """                            select o.id, o.group_account_id                            from dicom_order o, authentication_token at                            where o.mcid = at.at_account_id                            and at.at_token = ${anonAuth.value}                         """)                if(row)         log.info "Address ${req.remoteAddr} white listed for order " + row.id + " to group account " + row.group_account_id                return row?.group_account_id    }        def checkCookie(def mc) {        log.info "decoding cookie " + mc
        def enc = mc.split(',').find { it.startsWith('enc=') }?.substring(4)
        
        enc = enc.replaceAll('-','+')
        enc = enc.replaceAll('_','/')                // def secret = "secret"
        def secret = settings.SECRET
        def bytes = Base64.decodeBase64(enc.getBytes("UTF-8"))                MessageDigest md = MessageDigest.getInstance("SHA1");        byte[] key_data = md.digest(secret.getBytes("UTF-8"));        IvParameterSpec ivSpec = new IvParameterSpec(bytes, 0, 16);        SecretKeySpec k = new SecretKeySpec(key_data, 0, 16, "AES");        Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding");        c.init(Cipher.DECRYPT_MODE, k, ivSpec);        def decoded = new String(c.doFinal(bytes, 16, bytes.length - 16))                log.info "Decoded cookie: $decoded"                def result = [:]        decoded.split('&').each {            def pair = it.split('=')            result[pair[0]] = pair[1]        }                // Convert to long to map to users table 
        result.mcid = Long.parseLong(result.mcid)
        return result
    }        static void testDecoding() {                println "Testing"
        def mc = "mcid=1117658438174637,from=MedCommons,fn=Demo,ln=Doctor,email=demodoctor@medcommons.net,s=2,enc=7LHdUWUYMUXl8mBS9Ouy39VBkeyENN5LtFysETQ1oSWkKLLrGJShrskT3oJcofNWWukhC6cs43yogi0oDYQSW9r8Jr8DJbwOr7Yp_t9UOEGUJ5uwfAy8You3QNeHDweOE9cfQ5I6u8faR_MqMrBSP5IfqHcYcMFf-GdT3DlZr-crqN_4pf4ageZqrsH737bvzPOW8xsTtrJ-HV04PQwcdg=="
        
        SecurityFilters sf = new SecurityFilters()
        def props = sf.checkCookie(mc)        println "Decoded auth: ${props.auth}"
        assert props.auth == "8093cded752195b9d54f3d970c990ac9845fbac9"
            }}
